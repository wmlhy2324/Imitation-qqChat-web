# EasyChat Web 项目设计文档

## WebSocket 消息状态管理与ACK机制

### 概述

本系统实现了智能的WebSocket消息状态管理，支持自动检测后端ACK模式并进行相应处理，确保消息状态的准确显示和用户体验的一致性。

### 后端ACK机制分析

#### ACK模式类型

根据后端`/apps/im/ws/websocket/server.go`的实现，支持三种ACK模式：

1. **NoAck模式**（默认）
   - 服务器不发送任何ACK确认消息
   - FrameType不包含`FrameAck`响应
   - 适用于对消息可靠性要求不高的场景

2. **OnlyAck模式** 
   - 服务器立即回复`FrameAck`确认消息
   - FrameType: 2，包含原消息Id和AckSeq
   - 提供基本的消息送达确认

3. **RigorAck模式**
   - 严格的双向确认机制
   - 需要客户端再次确认服务器的ACK
   - 提供最高级别的消息可靠性保证

### 前端设计方案

#### 消息状态定义

```javascript
// 消息状态枚举
const MESSAGE_STATUS = {
  SENDING: 'sending',    // 发送中（显示转圈圈）
  SENT: 'sent',         // 已发送（显示单勾，灰色）
  DELIVERED: 'delivered', // 已送达（显示单勾，蓝色）
  READ: 'read'          // 已读（显示单勾，绿色）
}
```

#### 智能ACK模式检测

##### 检测机制

```javascript
class WebSocketManager {
  constructor() {
    this.ackMode = null           // ACK模式：null(检测中), 'noack', 'ack'
    this.ackDetectionCount = 0    // ACK检测计数器
    this.pendingMessages = new Map() // 等待ACK确认的消息
  }
}
```

##### 检测流程

1. **初始检测阶段**
   - 前3条消息用于ACK模式检测
   - 每条消息等待500ms检测ACK响应
   - 检测窗口设计考虑网络延迟和服务器处理时间

2. **模式判定逻辑**
   ```javascript
   // 收到ACK响应 → 立即确定为ACK模式
   if (receivedAck) {
     this.ackMode = 'ack'
   }
   
   // 500ms内无ACK + 连续3条消息 → 确定为NoAck模式  
   if (noAckFor3Messages) {
     this.ackMode = 'noack'
   }
   ```

3. **模式记忆机制**
   - 一旦检测出模式，后续消息直接按该模式处理
   - 避免重复检测，提高性能

#### 消息状态处理策略

##### NoAck模式处理
```javascript
// WebSocket发送成功后100ms直接更新为已发送
setTimeout(() => {
  this.updateMessageStatus(messageId, 'sent', tempMessageId, tempTimestamp)
}, 100)
```

##### ACK模式处理
```javascript
// 等待服务器ACK响应，收到后更新为已送达
handleAckMessage(message) {
  this.updateMessageStatus(message.id, 'delivered', tempMessageId, tempTimestamp)
}
```

#### 消息ID关联机制

##### 三层匹配策略

解决临时消息ID与WebSocket消息ID的关联问题：

```javascript
updateMessageStatus(messageId, status, tempMessageId, tempTimestamp) {
  // 1. 优先通过临时消息ID精确匹配
  if (tempMessageId) {
    messageIndex = messagesList.findIndex(msg => msg.id === tempMessageId)
  }
  
  // 2. 时间戳匹配（备用方案）
  if (messageIndex === -1 && tempTimestamp) {
    messageIndex = messagesList.findIndex(msg => 
      msg.id.startsWith('temp_') && 
      Math.abs(msg.sendTime - tempTimestamp) < 1000
    )
  }
  
  // 3. WebSocket消息ID匹配（ACK场景）
  if (messageIndex === -1) {
    messageIndex = messagesList.findIndex(msg => msg.id === messageId)
  }
}
```

#### 数据结构访问优化

##### ChatStore消息存储结构

```javascript
// 消息存储在 messages Map 中
this.chatStore.messages = new Map()
// 结构：conversationId -> messagesList[]

// 正确的访问方式
for (const [conversationId, messagesList] of this.chatStore.messages) {
  // 处理消息列表
}
```

##### Vue响应式更新

```javascript
// 触发Vue响应式更新
const updatedMessage = { ...oldMessage, status }
messagesList.splice(messageIndex, 1, updatedMessage)
```

### 技术实现细节

#### 时序设计

```
用户发送消息
    ↓
生成临时消息ID (temp_timestamp)
    ↓  
显示消息状态为'sending'（转圈圈）
    ↓
WebSocket发送消息
    ↓
ACK模式检测 (前3条消息)
    ↓
NoAck模式: 100ms后 → 'sent'状态（勾）
ACK模式: 等待ACK → 'delivered'状态（勾）
```

#### 防抖和去重机制

1. **消息去重**：通过消息ID避免重复添加
2. **状态防抖**：避免快速连续的状态更新
3. **超时处理**：长时间无响应的消息标记为失败

#### 错误处理

```javascript
// WebSocket发送失败
if (!success) {
  tempMessage.status = 'failed'
  ElMessage.error('消息发送失败，请检查网络连接')
}

// 消息状态更新失败
if (!this.updateMessageStatus(...)) {
  console.warn('消息状态更新失败')
}
```

### 优势与特点

#### 用户体验优化

1. **无感知切换**：自动适配不同ACK模式，用户无需感知
2. **即时反馈**：消息发送后立即显示，避免界面卡顿
3. **状态准确**：避免NoAck模式下的转圈圈问题
4. **避免闪烁**：OnlyAck模式下不会出现状态跳变

#### 技术优势

1. **智能检测**：自动检测后端ACK配置，无需手动配置
2. **容错性强**：支持网络延迟，避免误判
3. **性能优化**：模式记忆机制避免重复检测
4. **扩展性好**：易于支持新的ACK模式

### 配置项

#### 检测参数配置

```javascript
const ACK_DETECTION_CONFIG = {
  detectionTimeout: 500,      // ACK检测超时时间（毫秒）
  detectionMessageCount: 3,   // 用于检测的消息数量
  noAckUpdateDelay: 100,      // NoAck模式状态更新延迟（毫秒）
  timestampTolerance: 1000    // 时间戳匹配容差（毫秒）
}
```

### 测试用例

#### ACK模式检测测试

1. **NoAck模式测试**
   - 发送3条消息，均不收到ACK
   - 验证500ms后状态更新为'sent'
   - 验证第3条消息后模式确定为'noack'

2. **OnlyAck模式测试**
   - 发送消息后收到ACK响应
   - 验证状态直接更新为'delivered'
   - 验证后续消息等待ACK处理

3. **边界情况测试**
   - ACK延迟接近500ms的情况
   - 网络异常情况下的模式检测
   - 消息ID关联的各种匹配场景

### 维护说明

#### 日志监控

重要的日志输出点：
- ACK模式检测结果
- 消息状态更新成功/失败
- WebSocket连接状态变化
- 消息ID匹配结果

#### 问题排查

常见问题和解决方案：
1. 消息一直转圈圈 → 检查消息ID匹配逻辑
2. 状态更新失败 → 检查ChatStore数据结构访问
3. ACK模式误判 → 调整检测超时时间
4. Vue响应式失效 → 确认使用splice更新数组

---

*本文档记录了WebSocket消息状态管理的完整设计思路和实现细节，为后续维护和扩展提供参考。*
